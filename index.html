<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Mobile Aim Trainer</title>
    <style>
        body { margin: 0; overflow: hidden; background: #111; font-family: sans-serif; touch-action: none; }
        #ui { position: absolute; top: 10px; left: 10px; color: white; font-size: 20px; pointer-events: none; z-index: 10; }
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(0,0,0,0.8); color: white; z-index: 20;
        }
        #countdown { font-size: 80px; color: #00ffcc; display: none; }
    </style>
</head>
<body>

    <div id="ui">Score: <span id="score">0</span></div>
    
    <div id="overlay" id="startBtn">
        <h1 id="msg">TAP TO START</h1>
        <div id="countdown">3</div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';

        let score = 0;
        let gameActive = false;
        const targets = [];
        
        // Touch rotation variables
        let lon = 0, lat = 0;
        let phi = 0, theta = 0;
        let onPointerDownPointerX = 0, onPointerDownPointerY = 0;
        let onPointerDownLon = 0, onPointerDownLat = 0;

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        function playSound(freq, type, duration) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.5));

        // Start Game Event
        const overlay = document.getElementById('overlay');
        overlay.addEventListener('click', () => {
            if (gameActive) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            document.getElementById('msg').style.display = 'none';
            startCountdown();
        });

        function startCountdown() {
            let count = 3;
            const cd = document.getElementById('countdown');
            cd.style.display = 'block';
            cd.innerText = count;
            
            const timer = setInterval(() => {
                count--;
                if (count > 0) {
                    cd.innerText = count;
                    playSound(440, 'sine', 0.1);
                } else {
                    clearInterval(timer);
                    overlay.style.display = 'none';
                    gameActive = true;
                    spawnLoop();
                }
            }, 1000);
        }

        function spawnLoop() {
            if (!gameActive) return;
            const geo = new THREE.SphereGeometry(0.7, 16, 16);
            const mat = new THREE.MeshBasicMaterial({ color: 0x00ffcc, wireframe: true });
            const target = new THREE.Mesh(geo, mat);
            
            target.position.set((Math.random()-0.5)*20, (Math.random()-0.5)*15, -15);
            scene.add(target);
            targets.push(target);
            
            setTimeout(() => {
                scene.remove(target);
                targets.splice(targets.indexOf(target), 1);
            }, 2000);
            setTimeout(spawnLoop, 1200);
        }

        // MOBILE CONTROLS: Drag to Look
        document.addEventListener('pointerdown', (e) => {
            onPointerDownPointerX = e.clientX;
            onPointerDownPointerY = e.clientY;
            onPointerDownLon = lon;
            onPointerDownLat = lat;

            // Shooting Logic on Tap
            if(gameActive) {
                const mouse = new THREE.Vector2();
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(targets);
                
                if (intersects.length > 0) {
                    scene.remove(intersects[0].object);
                    targets.splice(targets.indexOf(intersects[0].object), 1);
                    score++;
                    document.getElementById('score').innerText = score;
                    playSound(800, 'triangle', 0.1);
                }
            }
        });

        document.addEventListener('pointermove', (e) => {
            if (e.isPrimary === false) return;
            lon = (onPointerDownPointerX - e.clientX) * 0.1 + onPointerDownLon;
            lat = (e.clientY - onPointerDownPointerY) * 0.1 + onPointerDownLat;
        });

        function animate() {
            requestAnimationFrame(animate);
            lat = Math.max(-85, Math.min(85, lat));
            phi = THREE.MathUtils.degToRad(90 - lat);
            theta = THREE.MathUtils.degToRad(lon);

            camera.target = new THREE.Vector3(
                500 * Math.sin(phi) * Math.cos(theta),
                500 * Math.cos(phi),
                500 * Math.sin(phi) * Math.sin(theta)
            );
            camera.lookAt(camera.target);
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
